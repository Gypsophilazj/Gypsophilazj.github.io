<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>L3Hctf复现</title>
      <link href="/2025/07/16/L3Hctf%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/07/16/L3Hctf%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="L3HCTF复现"><a href="#L3HCTF复现" class="headerlink" title="L3HCTF复现"></a>L3HCTF复现</h1><h2 id="ez-android"><a href="#ez-android" class="headerlink" title="ez_android"></a>ez_android</h2><p>先将程序拖进jadx中分析</p><p>找到MainActivity</p><p>通过mainactivity找到TauriActivity</p><p>再通过TauriActivity找到WryActivity</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716120514514.png" alt="1752638685032"></p><p>发现主要逻辑都在native层里面</p><p>把so文件放进ida中分析</p><p>随便填点东西在程序里</p><p>输出了Wrong answer</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716120214465.png" alt="1752638522730"></p><p>再根据这个字符串<br>在so层里面找</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716140031309.png" alt="1752645622731"></p><p>找到了greet函数</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716140158501.png" alt="1752645713404"></p><p>这里采用正向爆破的方法</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">#include&lt;stdint.h&gt;</span><br><span class="line">void jiami(uint8_t *a)&#123;</span><br><span class="line">uint64_t v10;</span><br><span class="line">uint8_t v11;</span><br><span class="line">unsigned char aDghpc2lzywtleq[]=&quot;dGhpc2lzYWtleQ&quot;;</span><br><span class="line">for (int i = 0LL; i != 27; ++i )</span><br><span class="line">&#123;</span><br><span class="line">v10 = i - 14;</span><br><span class="line">if ( i &lt; 0xE )</span><br><span class="line">v10 = i;</span><br><span class="line">v11 = aDghpc2lzywtleq[(((2 * i) | 1) - 14 * ((147 * ((2 * i) | 1u)) &gt;&gt; 11))] + (a[i] ^ aDghpc2lzywtleq[v10]);</span><br><span class="line">a[i] = aDghpc2lzywtleq[(i + 4) % 0xEu] ^ ((v11 &lt;&lt; (aDghpc2lzywtleq[(i + 3) % 0xEu] &amp; 7)) | (v11 &gt;&gt; (-aDghpc2lzywtleq[(i + 3) % 0xEu] &amp; 7)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int check(uint8_t *a,uint8_t *b)&#123;</span><br><span class="line">int count=0;</span><br><span class="line">for(int i=0;i&lt;28;i++)&#123;</span><br><span class="line">if(a[i]==b[i])</span><br><span class="line">count++;</span><br><span class="line">else </span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">uint8_t flag[28];</span><br><span class="line">uint8_t v19[11];</span><br><span class="line">uint8_t enc[28];</span><br><span class="line">uint8_t tmp[28];</span><br><span class="line">memcpy(&amp;v19[8], &quot;O2*&quot;, 3);</span><br><span class="line">*(uint64_t *)v19 = 0xFC020A4C0E2C7290;</span><br><span class="line">*(uint64_t *)enc = 0xA409663A025150C;</span><br><span class="line">*((uint64_t *)enc+1) = 0x1FE106294065165C;</span><br><span class="line">*((uint64_t *)enc+2) = 0xFC020A4C0E2C7290;</span><br><span class="line">*(uint64_t *)(enc+19) = *(uint64_t *)&amp;v19[3];</span><br><span class="line">memset(flag,0,28);</span><br><span class="line">for(int i=0;i&lt;28;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;128;j++)&#123;</span><br><span class="line">memset(tmp,0,28);</span><br><span class="line">memcpy(tmp,flag,28);</span><br><span class="line">tmp[i]=j;</span><br><span class="line">jiami(tmp);</span><br><span class="line">if(check(tmp,enc)&gt;=i+1)</span><br><span class="line">&#123;</span><br><span class="line">flag[i]=j;</span><br><span class="line">printf(&quot;%s\n&quot;,flag);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学到的东西：</p><table><thead><tr><th align="left">表达式</th><th align="left">指针运算的步长</th><th align="left">地址偏移量</th><th align="left">实际访问地址</th></tr></thead><tbody><tr><td align="left"><code>*((uint64_t *)enc + 2)</code></td><td align="left"><code>sizeof(uint64_t)</code>（8 字节）</td><td align="left">16 字节</td><td align="left"><code>enc + 16</code></td></tr><tr><td align="left"><code>*(uint64_t *)(enc + 2)</code></td><td align="left"><code>enc</code> 的原始类型（通常是 1 字节）</td><td align="left">2 字节</td><td align="left"><code>enc + 2</code></td></tr></tbody></table><h2 id="终焉之门"><a href="#终焉之门" class="headerlink" title="终焉之门"></a>终焉之门</h2><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716193956211.png" alt="1752665985141"></p><p>打开界面如上</p><p>直接拖进ida中进行分析<br>直接搜索关键词</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716194048845.png" alt="1752666042227"></p><p>找到关键函数</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716194151341.png" alt="1752666095588"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716194229283.png" alt="1752666134705"></p><p>主要逻辑不太看的懂</p><p>丢给ai<br>说是</p><p>该程序实质是一个结合图形API的密码验证器，核心验证逻辑依赖于GPU计算，需进一步分析着色器代码才能获取有效Flag。</p><p>而这两个函数都和着色器有关系<br><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716194737429.png" alt="1752666411598"></p><p>跟进去看看</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716194832772.png" alt="1752666501074"></p><p>一眼看上去像是乱码一样</p><p>估计是进行了某种加密，阻碍静态分析的</p><p>但程序在运行时如果需要执行这段代码</p><p>肯定需要进行解密</p><p>所以试着通过动调来查看</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716195313773.png" alt="1752666782628"></p><p>程序执行过这两个函数后，点进去查看</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716195131203.png" alt="image-20250716195131149"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716195135284.png" alt="1752666681169"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716195202692.png" alt="1752666712176"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716195219013.png" alt="1752666733541"></p><p>发现是VM</p><p>通过分析可得</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250716195826041.png" alt="1752667100533"></p><p>提取出opcode以及主要的程序逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dword_7FF7C69E30E0[168] = &#123;</span><br><span class="line">    0x00000002, 0x00000000, 0x00000002, 0x00000001, 0x00000002, 0x00000000, 0x0000000E, 0x00000000, </span><br><span class="line">    0x00000002, 0x00000010, 0x00000008, 0x00000000, 0x00000002, 0x00000002, 0x00000002, 0x00000001, </span><br><span class="line">    0x0000000E, 0x00000000, 0x00000002, 0x00000011, 0x00000008, 0x00000000, 0x00000002, 0x00000003, </span><br><span class="line">    0x00000002, 0x00000002, 0x0000000E, 0x00000000, 0x00000002, 0x00000012, 0x00000007, 0x00000000, </span><br><span class="line">    0x00000002, 0x00000004, 0x00000002, 0x00000003, 0x0000000E, 0x00000000, 0x00000002, 0x00000013, </span><br><span class="line">    0x00000007, 0x00000000, 0x00000002, 0x00000005, 0x00000002, 0x00000004, 0x0000000E, 0x00000000, </span><br><span class="line">    0x00000002, 0x00000014, 0x00000008, 0x00000000, 0x00000002, 0x00000006, 0x00000002, 0x00000005, </span><br><span class="line">    0x0000000E, 0x00000000, 0x00000002, 0x00000015, 0x00000007, 0x00000000, 0x00000002, 0x00000007, </span><br><span class="line">    0x00000002, 0x00000006, 0x0000000E, 0x00000000, 0x00000002, 0x00000016, 0x00000007, 0x00000000, </span><br><span class="line">    0x00000002, 0x00000008, 0x00000002, 0x00000007, 0x0000000E, 0x00000000, 0x00000002, 0x00000017, </span><br><span class="line">    0x00000007, 0x00000000, 0x00000002, 0x00000009, 0x00000002, 0x00000008, 0x0000000E, 0x00000000, </span><br><span class="line">    0x00000002, 0x00000018, 0x00000007, 0x00000000, 0x00000002, 0x0000000A, 0x00000002, 0x00000009, </span><br><span class="line">    0x0000000E, 0x00000000, 0x00000002, 0x00000019, 0x00000007, 0x00000000, 0x00000002, 0x0000000B, </span><br><span class="line">    0x00000002, 0x0000000A, 0x0000000E, 0x00000000, 0x00000002, 0x0000001A, 0x00000007, 0x00000000, </span><br><span class="line">    0x00000002, 0x0000000C, 0x00000002, 0x0000000B, 0x0000000E, 0x00000000, 0x00000002, 0x0000001B, </span><br><span class="line">    0x00000008, 0x00000000, 0x00000002, 0x0000000D, 0x00000002, 0x0000000C, 0x0000000E, 0x00000000, </span><br><span class="line">    0x00000002, 0x0000001C, 0x00000008, 0x00000000, 0x00000002, 0x0000000E, 0x00000002, 0x0000000D, </span><br><span class="line">    0x0000000E, 0x00000000, 0x00000002, 0x0000001D, 0x00000007, 0x00000000, 0x00000002, 0x0000000F, </span><br><span class="line">    0x00000002, 0x0000000E, 0x0000000E, 0x00000000, 0x00000002, 0x0000001E, 0x00000008, 0x00000000, </span><br><span class="line">    0x00000010, 0x00000000, 0x00000002, 0x00000010, 0x00000002, 0x00000011, 0x0000000F, 0x00000000, </span><br><span class="line">    0x00000012, 0x00000054, 0x00000002, 0x0000001F, 0x00000001, 0x00000000, 0x00000003, 0x00000001</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    if (gl_GlobalInvocationID.x &gt; 0) return;</span><br><span class="line"></span><br><span class="line">    uint ip = 0;</span><br><span class="line">    int sp = 0;</span><br><span class="line">    verdict = -233;</span><br><span class="line"></span><br><span class="line">    while (ip &lt; uint(MaxInstructionCount)) &#123;</span><br><span class="line">        int opcode = opcodes[int(ip)];</span><br><span class="line">        int arg    = opcodes[int(ip)+1];</span><br><span class="line"></span><br><span class="line">        switch (opcode) &#123;</span><br><span class="line">            case 2:</span><br><span class="line">                stack_data[sp++] = co_consts[arg];</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 7:</span><br><span class="line">                int b = stack_data[--sp];</span><br><span class="line">                int a = stack_data[--sp];</span><br><span class="line">                stack_data[sp++] = a + b;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 8:</span><br><span class="line">                int a = stack_data[--sp];</span><br><span class="line">                int b = stack_data[--sp];</span><br><span class="line">                stack_data[sp++] = a - b;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 14:</span><br><span class="line">                int b = stack_data[--sp];</span><br><span class="line">                int a = stack_data[--sp];</span><br><span class="line">                stack_data[sp++] = a ^ b;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 15:</span><br><span class="line">                int b = stack_data[--sp];</span><br><span class="line">                int a = stack_data[--sp];</span><br><span class="line">                stack_data[sp++] = int(a == b);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case 16:</span><br><span class="line">                bool ok = true;</span><br><span class="line">                for (int i = 0; i &lt; 16; i++) &#123;</span><br><span class="line">                    if (stack_data[i] != (cipher[i] - 20)) &#123;</span><br><span class="line">                        ok = false;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                verdict = ok ? 1 : -1;</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            case 18:</span><br><span class="line">                int c = stack_data[--sp];</span><br><span class="line">                if (c == 0) ip = uint(arg);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                verdict = 500;</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ip += 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    verdict = 501;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据opcode推测flag就是先经过一次异或再进行一次sub或者add</p><p>模拟压栈和出栈的规律</p><p>最后和cipher-20的数据进行比较</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">unsigned int cipher[]=&#123;0xF3, 0x82, 0x06, 0x1FD,</span><br><span class="line">0x150, 0x38, 0xB2, 0xDE,</span><br><span class="line">0x15A, 0x197, 0x9C, 0x1D7,</span><br><span class="line">0x6E, 0x28, 0x146, 0x97&#125;;</span><br><span class="line">unsigned int co_consts[] = &#123; 0xB0, 0xC8,</span><br><span class="line">0xFA, 0x86, 0x6E, 0x8F, 0xAF, 0xBF, 0xC9, 0x64, 0xD7, 0xC3, 0xE3, 0xEF, 0x87, 0x00&#125;;</span><br><span class="line">unsigned int flag[16];</span><br><span class="line">for(int i=0;i&lt;16;i++)&#123;</span><br><span class="line">cipher[i]-=20;</span><br><span class="line">&#125;</span><br><span class="line">int a[]=&#123;1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0&#125;;</span><br><span class="line">flag[0]=cipher[0];</span><br><span class="line">for(int i=1;i&lt;16;i++)&#123;</span><br><span class="line">if(a[i]==0)</span><br><span class="line">flag[i]=(co_consts[i-1]-cipher[i])^flag[i-1];</span><br><span class="line">//cipher[i]=co_consts[i-1]-(flag[i]^flag[i-1])</span><br><span class="line">else</span><br><span class="line">flag[i]=(cipher[i]-co_consts[i-1])^flag[i-1];</span><br><span class="line">//cipher[i]=co_consts[i-1]+(flag[i]^flag[i-1])</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;16;i++)</span><br><span class="line">printf(&quot;%x&quot;,flag[i]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题目复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> L3Hctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0xB</title>
      <link href="/2025/07/11/Frida%200xB/"/>
      <url>/2025/07/11/Frida%200xB/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0xB"><a href="#Frida-0xB" class="headerlink" title="Frida 0xB"></a>Frida 0xB</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164839537.png" alt="微信截图_20250710170107"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164839860.png" alt="微信截图_20250710170120"></p><p>通过分析上述代码可以看到主要逻辑还是在native层中的getFlag函数中</p><p>下面到so层进行分析</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164839953.png" alt="微信截图_20250710170221"></p><p>反编译出来发现什么都没有</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164840184.png" alt="微信截图_20250710170259"></p><p>但在汇编界面又能看到有东西</p><p>所以估计是进行了某些操作阻碍了ida的反编译</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164840253.png" alt="微信截图_20250710170513"></p><p>我们看到这里</p><p>它给rbp+var_24赋值为0x0DEADBEEF</p><p>cmp     [rbp+var_24], 539</p><p>又将这个值与0x539比较</p><p>所以这段代码永假，所以下面的代码全都会被跳过，不执行</p><p>这里直接nop掉</p><p>再反编译程序就出来了</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164840282.png" alt="微信截图_20250710170823"></p><p>所以我们只需要通过hook把刚才那个永假条件改成nop就行</p><p>大概思路就是找到那个永假条件的代码对应的地址</p><p>然后更改它的十六进制数据</p><p>改成90(nop)即可</p><p>或者改成74(jz)</p><p>具体代码实现是参考网上的wp写的</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function hookTestB()&#123;</span><br><span class="line">var libc_base = Module.getBaseAddress(&quot;libfrida0xb.so&quot;) //libc基地址</span><br><span class="line">var jnz = libc_base.add(0x170CE); //JNZ所在偏移</span><br><span class="line">console.log(&quot;libc_base : &quot;,libc_base);</span><br><span class="line">console.log(&quot;jnz : &quot;,jnz);</span><br><span class="line"></span><br><span class="line">Memory.protect(jnz, 0x1000, &quot;rwx&quot;); //赋予rwx权限</span><br><span class="line">var writer = new X86Writer(jnz);</span><br><span class="line"></span><br><span class="line">// 读取内存范围内的指令</span><br><span class="line">var size = 0x30; // 读取的字节数</span><br><span class="line">var instructionBytes = Memory.readByteArray(jnz, size);</span><br><span class="line">console.log(&quot;instructionBytes ：&quot;,instructionBytes);</span><br><span class="line">// 解析并输出汇编指令</span><br><span class="line">var instructions = Instruction.parse(jnz, instructionBytes);</span><br><span class="line">console.log(&quot;instructions ：&quot;,instructions);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    for (var i = 0; i &lt; 0x170D4-0x170CE; i++) &#123; //填充6个NOP</span><br><span class="line">        writer.putNop()</span><br><span class="line">    &#125;</span><br><span class="line">    writer.flush();// 刷新指令缓存</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">  writer.dispose();// 释放writer对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instructionBytes = Memory.readByteArray(jnz, size);</span><br><span class="line">console.log(&quot;new instructionBytes ：&quot;,instructionBytes);</span><br><span class="line">// 解析并输出汇编指令</span><br><span class="line">var instructions = Instruction.parse(jnz, instructionBytes);</span><br><span class="line">console.log(&quot;new instructions ：&quot;,instructions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTestB();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0xA</title>
      <link href="/2025/07/11/Frida%200xA/"/>
      <url>/2025/07/11/Frida%200xA/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0xA"><a href="#Frida-0xA" class="headerlink" title="Frida 0xA"></a>Frida 0xA</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164838850.png" alt="微信截图_20250710163210"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164838880.png" alt="微信截图_20250710163113"></p><p>基本上都是些初始化及画面设置的代码<br>主要就是native层的stringFromJNI</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164838936.png" alt="微信截图_20250710163622"></p><p>仔细分析了一下</p><p>发现也没有什么和flag有关的东西</p><p>再看看左手边的函数表</p><p>发现有一个get_flag</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164839339.png" alt="微信截图_20250710163806"></p><p>所以我们需要主动调用so文件中的get_flag并在日志中查看即可</p><p>这里需要注意的是get_flag在so文件中并非真叫get_flag</p><p>而是需要切到汇编函数中去看</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164839368.png" alt="微信截图_20250710165243"></p><p>函数名字为_Z8get_flagii</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function hookTestA()&#123;</span><br><span class="line">var funcAddr = Module.findExportByName(&quot;libfrida0xa.so&quot;,&quot;_Z8get_flagii&quot;);</span><br><span class="line">//声明函数指针</span><br><span class="line">if (!funcAddr) &#123;</span><br><span class="line">        console.error(&quot;Function not found!&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//NativeFunction的第一个参数是地址，第二个参数是返回值类型，第三个[]里的是传入的参数类型(有几个就填几个)</span><br><span class="line">var aesAddr = new NativeFunction(funcAddr , &#x27;uint64&#x27;, [&#x27;int&#x27;, &#x27;int&#x27;]);</span><br><span class="line">console.log(&quot;hook&quot;);</span><br><span class="line">aesAddr(1,2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTestA();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>先用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat</span><br></pre></td></tr></table></figure><p>开启实时日志监控</p><p>再进行hook</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164839391.png" alt="微信截图_20250710165032"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0x9</title>
      <link href="/2025/07/11/Frida%200x9/"/>
      <url>/2025/07/11/Frida%200x9/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0x9"><a href="#Frida-0x9" class="headerlink" title="Frida 0x9"></a>Frida 0x9</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164838243.png" alt="微信截图_20250710162611"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164838381.png" alt="微信截图_20250710162554"></p><p>由上面的代码可知</p><p>我们只需要修改check_flag的值，让它返回值为1337即可</p><p>下面进到so层看看</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164838742.png" alt="微信截图_20250710162736"></p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function hookTest9()&#123;</span><br><span class="line">    let MainActivity = Java.use(&quot;com.ad2001.a0x9.MainActivity&quot;);</span><br><span class="line">MainActivity[&quot;check_flag&quot;].implementation = function () &#123;</span><br><span class="line">    console.log(`MainActivity.check_flag is called`);</span><br><span class="line">    let result = this[&quot;check_flag&quot;]();</span><br><span class="line">    console.log(`MainActivity.check_flag result=$&#123;result&#125;`);</span><br><span class="line">    return 1337;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTest9();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164838791.png" alt="微信截图_20250710162908"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0x8</title>
      <link href="/2025/07/11/Frida%200x8/"/>
      <url>/2025/07/11/Frida%200x8/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0x8"><a href="#Frida-0x8" class="headerlink" title="Frida 0x8"></a>Frida 0x8</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837760.png" alt="微信截图_20250710161113"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837911.png" alt="微信截图_20250710161119"></p><p>可以看到这里的主要逻辑就是cmpstr这个方法，而这个方法又是在native层实现的，所以我们要进到so文件里面去看</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837940.png" alt="微信截图_20250710161258"></p><p>从这我们可以看出s1就是我们输入的ip</p><p>s2就是flag</p><p>所以，我们可以通过hook strcmp这个函数</p><p>来获取s2的值</p><p>但是需要注意的是</p><p>strcmp这个函数在很多地方都会被调用</p><p>所以直接打印s2的值会有很多值</p><p>但是也能从输出的数据找到flag</p><p>但也费时间</p><p>这里优化了一下</p><p>当s1的值满足特定条件的时候我们再输出s2的值</p><p>在代码中我是让s1&#x3D;123</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function hookTest8()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        //根据导出函数名打印地址</span><br><span class="line">        var helloAddr = Module.findExportByName(&quot;libfrida0x8.so&quot;,&quot;strcmp&quot;);</span><br><span class="line">        console.log(helloAddr);</span><br><span class="line">        if(helloAddr != null)&#123;</span><br><span class="line">            Interceptor.attach(helloAddr,&#123;</span><br><span class="line">                //onEnter里可以打印和修改参数</span><br><span class="line">                onEnter: function(args)&#123;  //args传入参数</span><br><span class="line">                    // 方法一</span><br><span class="line">                    var jString = Memory.readUtf8String(args[1]);</span><br><span class="line">                    var jString1 = Memory.readUtf8String(args[0]);</span><br><span class="line">                    if(jString1.includes(&quot;123&quot;))&#123;</span><br><span class="line">                    console.log(&quot;flag:&quot;, jString);</span><br><span class="line">                &#125;</span><br><span class="line">                    // 方法二</span><br><span class="line">                    // var JNIEnv = Java.vm.getEnv();</span><br><span class="line">                    // var originalStrPtr = JNIEnv.getStringUtfChars(args[1], null).readCString();        </span><br><span class="line">                    // console.log(&quot;参数:&quot;, originalStrPtr);                                </span><br><span class="line">                &#125;,</span><br><span class="line">                //onLeave里可以打印和修改返回值</span><br><span class="line">                onLeave: function(retval)&#123;  //retval返回值</span><br><span class="line">                //     var returnedJString = Java.cast(retval, Java.use(&#x27;java.lang.String&#x27;));</span><br><span class="line">                //     console.log(&quot;返回值:&quot;, returnedJString);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            console.log(&quot;找不到该函数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164838167.png" alt="微信截图_20250710162046"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164838193.png" alt="微信截图_20250710162025"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0x7</title>
      <link href="/2025/07/11/Frida%200x7/"/>
      <url>/2025/07/11/Frida%200x7/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0x7"><a href="#Frida-0x7" class="headerlink" title="Frida 0x7"></a>Frida 0x7</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837477.png" alt="微信截图_20250710153252"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837581.png" alt="微信截图_20250710153302"></p><p>根据如上代码，这一题有两个思路</p><p>第一个是hook Checker类的构造方法，</p><p>让num1&gt;512并且num2&gt;512即可输出flag</p><p>第二个思路是利用Checker类的构造方法再构造一个新的Checker类，传的num1和num2都要大于512</p><p>再把这个类传给flag方法，即可输出flag</p><p>代码如下</p><p>这里需要注意的是，方法1需要通过frida中的-f来启动，用-F来启动无法实现，因为程序在启动时就已经执行了flag(ch);所以即使hook了构造方法ch也已经通过hook之前的构造方法生成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function hookTest7_1()&#123;</span><br><span class="line">    var utils = Java.use(&quot;com.ad2001.frida0x7.Checker&quot;);</span><br><span class="line">    //修改类的构造函数的实现，$init表示构造函数</span><br><span class="line">    utils.$init.overload(&#x27;int&#x27;,&#x27;int&#x27;).implementation = function(num1,num2)&#123;</span><br><span class="line">        console.log(num1,num2);</span><br><span class="line">        num1 = 1111;</span><br><span class="line">        num2 = 1111;</span><br><span class="line">        this.$init(num1,num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTest7_1();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function hookTest7_2()&#123;</span><br><span class="line">    Java.performNow(function()&#123;</span><br><span class="line">        //非静态字段的修改</span><br><span class="line">        //使用`Java.choose()`枚举类的所有实例</span><br><span class="line">        Java.choose(&quot;com.ad2001.frida0x7.MainActivity&quot;, &#123;</span><br><span class="line">            onMatch: function(obj)&#123;</span><br><span class="line">                    //修改实例的非静态字段&quot;_privateInt&quot;的值为&quot;123456&quot;，并修改非静态字段&quot;privateInt&quot;的值为9999。</span><br><span class="line">                //obj._privateInt.value = &quot;123456&quot;; //字段名与函数名相同 前面加个下划线</span><br><span class="line">                var utils = Java.use(&quot;com.ad2001.frida0x7.Checker&quot;);</span><br><span class="line">                var wey= utils.$new(600,600);</span><br><span class="line">                obj.flag(wey);</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTest7_2();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>方法2也同样有需要注意之处，方法2需要用-F才能够实现，因使用<code>-f</code>时，Frida会在应用<strong>启动初期</strong>就注入脚本此时<code>MainActivity</code>类可能尚未完全初始化，所以flag方法可能还未实现，所以无法输出flag，而-F的时候和，程序已经初始化完毕，flag方法也已经实现，故可以输出flag</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837744.png" alt="微信截图_20250710154821"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0x6</title>
      <link href="/2025/07/11/Frida%200x6/"/>
      <url>/2025/07/11/Frida%200x6/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0x6"><a href="#Frida-0x6" class="headerlink" title="Frida 0x6"></a>Frida 0x6</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837044.png" alt="微信截图_20250710152001"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837192.png" alt="微信截图_20250710152104"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837274.png" alt="微信截图_20250710152818"></p><p>看到如上代码可以得出</p><p>代码中写了get_flag</p><p>但没有地方调用它</p><p>所以，我们要通过hook Checker这个构造方法构造一个Checker类再给里面的num1和num2赋值</p><p>让num1&#x3D;1234，num2&#x3D;&#x3D;4321</p><p>再传入get_flag中，即可在程序中输出flag</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function hookTest6()&#123;</span><br><span class="line">        var ret = null;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        Java.choose(&quot;com.ad2001.frida0x6.MainActivity&quot;,&#123;    //要hook的类</span><br><span class="line">            onMatch:function(instance1)&#123;</span><br><span class="line">                var utils = Java.use(&quot;com.ad2001.frida0x6.Checker&quot;);</span><br><span class="line">                var instance2 = utils.$new();</span><br><span class="line">                instance2.num1.value=1234;</span><br><span class="line">                instance2.num2.value=4321;</span><br><span class="line">                instance1.get_flag(instance2); //要hook的方法</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete:function()&#123;</span><br><span class="line">                    //console.log(&quot;result: &quot; + ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTest6();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837300.png" alt="微信截图_20250710153125"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0x5</title>
      <link href="/2025/07/11/Frida%200x5/"/>
      <url>/2025/07/11/Frida%200x5/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0x5"><a href="#Frida-0x5" class="headerlink" title="Frida 0x5"></a>Frida 0x5</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836822.png" alt="微信截图_20250710151415"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836885.png" alt="微信截图_20250710151423"></p><p>根据上述代码可知</p><p>我们需要用hook非静态方法的方式hook flag方法</p><p>让code&#x3D;&#x3D;1337即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function hookTest5()&#123;</span><br><span class="line">        var ret = null;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        Java.choose(&quot;com.ad2001.frida0x5.MainActivity&quot;,&#123;    //要hook的类</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                instance.flag(1337); //要hook的方法</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete:function()&#123;</span><br><span class="line">                    //console.log(&quot;result: &quot; + ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTest5();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164837044.png" alt="微信截图_20250710152001"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0x4</title>
      <link href="/2025/07/11/Frida%200x4/"/>
      <url>/2025/07/11/Frida%200x4/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0x4"><a href="#Frida-0x4" class="headerlink" title="Frida 0x4"></a>Frida 0x4</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836457.png" alt="微信截图_20250710150721"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836543.png" alt="微信截图_20250710150743"></p><p>这里我们照常看到mainactivity</p><p>发现只是对这个界面进行了一些设置</p><p>没有flag</p><p>又看到存在一个check类</p><p>点开里面发现有get_flag函数</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836708.png" alt="微信截图_20250710150952"></p><p>但是这个方法实现完flag并不会输出到程序中去，而是作为返回值</p><p>所以我们需要通过hook构造一个Check类，再调用这个类中的get_flag令a&#x3D;&#x3D;1337并且打印执行这个方法之后的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function hookTest4()&#123;</span><br><span class="line">        var ClassName=Java.use(&quot;com.ad2001.frida0x4.Check&quot;); </span><br><span class="line">        var instance = ClassName.$new();</span><br><span class="line">        var a=instance.get_flag(1337);</span><br><span class="line">        console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTest4();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836731.png" alt="微信截图_20250710151324"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0x3</title>
      <link href="/2025/07/11/Frida%200x3/"/>
      <url>/2025/07/11/Frida%200x3/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0x3"><a href="#Frida-0x3" class="headerlink" title="Frida 0x3"></a>Frida 0x3</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836278.png" alt="微信截图_20250710150122"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836296.png" alt="微信截图_20250710150359"></p><p>这题也是，通过frida直接hook check.code更改这个静态变量的值为512即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function hookTest3()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        //静态字段的修改s</span><br><span class="line">        var utils = Java.use(&quot;com.ad2001.frida0x3.Checker&quot;);</span><br><span class="line">        //修改类的静态字段&quot;flag&quot;的值</span><br><span class="line">        utils.code.value = 512;</span><br><span class="line">        console.log(utils.code.value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTest3();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836346.png" alt="微信截图_20250710150540"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0x2</title>
      <link href="/2025/07/11/Frida%200x2/"/>
      <url>/2025/07/11/Frida%200x2/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0x2"><a href="#Frida-0x2" class="headerlink" title="Frida 0x2"></a>Frida 0x2</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164835767.png" alt="微信截图_20250710145509"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164835797.png" alt="微信截图_20250710145628"></p><p>通过分析这个代码可以知道<br>我们只需要通过hook主动调用get_flag让a&#x3D;&#x3D;4919就能输出flag<br>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function hookTest2()&#123;</span><br><span class="line">   var ClassName=Java.use(&quot;com.ad2001.frida0x2.MainActivity&quot;); </span><br><span class="line">        ClassName.get_flag(4919);</span><br><span class="line">&#125;</span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTest2();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164836231.png" alt="微信截图_20250710150017"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida 0x1</title>
      <link href="/2025/07/11/Frida%200x1/"/>
      <url>/2025/07/11/Frida%200x1/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida-0x1"><a href="#Frida-0x1" class="headerlink" title="Frida 0x1"></a>Frida 0x1</h1><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164835768.png" alt="微信截图_20250710145325"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164835772.png" alt="微信截图_20250710144144"></p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164835788.png" alt="微信截图_20250710144049"></p><p>根据上面的check方法可以看到</p><p>只要满足让(i*2)+4&#x3D;&#x3D;i2这个条件就能够输出flag</p><p>所以我们只需要hook check方法中的i和i2的值就行</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function hookTest1()&#123;</span><br><span class="line">        //获取一个名为&quot;类名&quot;的Java类，并将其实例赋值给JavaScript变量utils</span><br><span class="line">    var utils = Java.use(&quot;com.ad2001.frida0x1.MainActivity&quot;);</span><br><span class="line">    //修改&quot;类名&quot;的&quot;method&quot;方法的实现。这个新的实现会接收两个参数（a和b）</span><br><span class="line">    utils.check.implementation = function(a, b)&#123;</span><br><span class="line">            //将参数a和b的值改为123和456。</span><br><span class="line">        a = 1;</span><br><span class="line">        b = 6;</span><br><span class="line">        //调用修改过的&quot;method&quot;方法，并将返回值存储在`retval`变量中</span><br><span class="line">        this.check(a, b);</span><br><span class="line">        //在控制台上打印参数a，b的值以及&quot;method&quot;方法的返回值</span><br><span class="line">        console.log(a,b)</span><br><span class="line">        //返回&quot;method&quot;方法的返回值</span><br><span class="line">        //return retval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function main()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        hookTest1();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>运行后点submit</p><p><img src="https://gypsophila2j.oss-cn-beijing.aliyuncs.com/20250711164835770.png" alt="微信截图_20250710145235"></p>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
